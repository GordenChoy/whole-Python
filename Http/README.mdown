# Http入门葵花宝典

<hr/>

<a href="https://github.com/cbbfcd">@波比小金刚</a>

>如果觉得不错请扔个star过来。

> 如要转载，请注明出处。

<hr/>

[TOC]

<hr/>

## 1. web网络基础

### 1.1 HTTP概述

客户端通过一个URL向资源服务器请求资源并获取到资源，这一通信过程需要遵守HTTP协议,Web是建立在HTTP协议上通信的。

HTTP是 HyperText Transfer Protocol，译为超文本传输协议。

### 1.2 HTTP历史

1989年，欧洲核子研究组织的李博士提出了一种能让远隔两地的研究者们共享知识的设想。
基本理念是基于多种文本之间关联形成的超文本，连成可互相参阅的WWW(万维网)。

WWW 的主要构建技术:
1. HTML
2. HTTP
3. URL

HTTP的版本:
1. HTTP/0.9 1990年
2. HTTP/1.0 1996年
3. HTTP/1.1 1997年 目前主流的 HTTP 协议版本
4. HTTP/2.0 指日可待

### 1.3 TCP/IP 协议族

HTTP属于TCP/IP协议族的一个子集。所以我们需要了解部分TCP/IP协议族的知识。
TCP/IP协议族是互联网相关的各类协议族的统称，包括HTTP协议、IP协议等。

#### 1.3.1 TCP/IP协议族的分层管理

TCP/IP协议分层：

1. 应用层

    应用层决定了向用户提供应用服务时通信的活动。

    TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。

    HTTP 协议也处于该层。

2. 传输层

    提供处于网络中两台计算机之间的数据传输。

    在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。

3. 网络层

    网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。
    网络层主要的作用就是在网络传输中确定一条路线。

4. 链路层

    用来处理连接网络的硬件部分。包括控制操作系统、驱动、网卡等。

#### 1.3.2 TCP/IP 通信传输流

<a>部分图片看不见，请用chrome、opera等打开</a>
<img src="./tcp.png">


这一过程大致就是在发送端按照应用层->传输层->网络层->链路层方向传递。
每一层都会增加一个该层的首部信息，然后在接收端是按照链路层->网络层->传输层->应用层的方向接收，每层都会把对应的首部去除。

这种把数据信息包装起来的做法称为封装。

#### 1.3.3 IP协议、TCP协议、DNS协议

该层拥有和HTTP协议密不可分的IP协议、TCP协议、DNS协议。

1. IP

    IP是一种协议，不要和IP地址搞混淆了。
    IP协议位于网络层，其主要作用是保证数据包能够准确的送到对方。
    而要保证准确送到，主要依靠的是 IP地址 和 MAC地址。

    IP 地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。
    IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。

    ARP 协议凭借 MAC 地址进行通信：
    ARP 是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

    大致过程是发送端想要给一个IP地址发送数据，然后通过ARP协议解析出MAC地址。
    然后通过路由机制中转，这个过程具体有多少个中转是无法预知的，最后成功送达。

2. TCP 协议

    TCP协议位于传输层，提供可靠的字节流服务。

    字节流服务：
    就是把大块的数据分割成报文段为单位的数据包进行管理。

    可靠的则是指的是TCP协议能够保证把数据准确的送到对方。
    所以，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方。

    TCP用以保证数据准确送达的方式是采用了三次握手：

    >发送端首先发送一个带 SYN 标志的数据包给对方。然后对方返回一个带 SYN/ACK 的数据包表示收到了。发送端再回一个带 ACK 的数据包表示握手结束。
    >如果这一过程在某一个阶段中断，TCP 协议会再次以相同的顺序发 送相同的数据包。


3. DNS 服务

    提供域名到 IP 地址之间的解析服务。
    因为较之于域名，IP地址更难记忆。DNS服务就诞生了，DNS服务可以通过域名推导出IP地址，当然，反过来通过IP地址解析出域名也是可以的。

#### 1.3.4 一张图串联上述知识点

<a>部分图片看不见，请用chrome、opera等打开</a>
<img src="./http.png">

所以我们平时在浏览器地址栏输入一个地址，显示一个网页的过程大致如下：

发送端：
1. 应用层：DNS登场，根据域名解析出IP地址
2. 应用层：HTTP协议出场，生成一个HTTP请求报文
3. 传输层：TCP协议登场，将数据分割并通过三次握手向目标传递
4. 网络层：IP协议配合TCP协议，确定目的地，然后通过路由，一边路由一边传递数据包

接收端：
5. 网络层：数据送到
6. 传输层：TCP协议接收传递过来的数据包，并重组数据包。
7. 应用层：HTTP协议处理请求报文，生成响应报文。
8. 请求的结果再反向的一样的流程传回给发送端。

### 1.4 URL & URI

这是面试经常问到的一个问题，URL与URI的区别和联系(可能还会加上URN)。

#### 1.4.1 URL

统一资源定位符，通常有三部分组成：
1. 协议
2. 存有该资源的主机IP地址(有时也包括端口号)
3. 主机资源的具体地址。如目录和文件名等

每个资源文件有一个唯一的URL标识，还提供了操作、获取该资源的方法。或者这么说：
就是提供了一个唯一的路径去标识一个资源，并且还提供了操作、获取资源的方法。
简单来说就是不仅说明了 what the source is 还说明了 how to get it。

#### 1.4.2 URI

统一资源标识符。

URI用字符串标识某一互联网资源，而URL表示资源的地点（互联 网上所处的位置）。可见URL是URI的子集。当然URN也是URI的子集。

URI仅仅只是说明了 what the source is。


## 2. 熟悉HTTP/1.1

HTTP/1.1(以下简称HTTP)是目前主流的HTTP协议版本。

### 2.1 熟悉报文结构

HTTP协议用于客户端和服务端之间的通信。请求一定由客户端发起，服务端做出响应。
这里发起的请求和响应都是以报文的形式。大家可以在控制台F12看到请求、响应报文。
这里先熟悉一下报文结构，后边会具体讲讲里面的内容。

1. 请求报文

    一个简单的例子:

    ```
    POST /index.html HTTP/1.1         --对应--> 请求方式、请求URI、协议版本
    Host: hack.jp                     --对应--> 主机
    Connection: keep-alive            --对应--> 链接状态
    Content-Type: application/json    --对应--> 内容类型
    Content-Length: 16                --对应--> 内容长度
    ...

    name=tome&age=12                  --对应--> 内容实体
    ```

    提出代码:

    ```
    POST /index.html HTTP/1.1         --对应--> 请求方式、请求URI、协议版本
    Host: hack.jp                     --对应--> 主机
    ```

    根据这两行信息，可以获悉的URI完整表示应该是:http://hack.jp/index.html
    如果要对服务器本身发起请求，可以把 请求URI 指定为 * 。

    ```
    POST * HTTP/1.1
    ```

2. 响应报文

    一个简单的例子:

    ```
    HTTP/1.1 200 OK                       --对应-->协议版本、状态码、状态码原因短语
    Date: Tue, 10 Jul 2017 10:18:55 GMT   --对应-->日期 、响应首部字段
    Content-Length: 362
    Content-Type: text/html

    ...

    <html>                                 --对应--> 报文主体
    ...
    </html>
    ```


### 2.2 Cookie即将登场

这里说Cookie不合适，只是抛砖引玉。

>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。

那就坑爹了不是，不能我登进一个网站，然后点了另一个页面就GG了是吧，所以引入了Cookie技术用来管理状态。

Cookie的知识在后边...在后边...在后边...

### 2.3 HTTP/1.1 中可使用的方法

1. GET 获取资源

    GET 方法用来请求访问已被 URI 识别的资源。

2. POST 传输实体主体

    POST 方法用来传输实体的主体。GET也可以干这活，具体就是GET & POST的区别了。

3. PUT 传输文件

    PUT 方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

    HTTP协议的PUT方法本身不带有验证机制，因此除了在REST结构的WEB网站中才有可能使用。响应的状态码如果是 204，表示的是发送成功，但是没有数据返回。

4. HEAD 获得报文首部

    同GET一样，只是返回的东西不包括报文主体。

5. DELETE 删除文件

    DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。

    HTTP协议的DELETE方法本身不带有验证机制，因此除了在REST结构的WEB网站中才有可能使用。响应的状态码如果是 204，表示的是发送成功，但是没有数据返回。

6. OPTIONS 询问支持

    就是询问支持哪些方法，返回的是包含 Allow: GET,POST... 的报文

7. TRACE 追踪路径

    通过该方法可以追踪请求是怎么一步一步被加工的，但是极其不安全。一般不用。

8. CONNECT 隧道协议连接代理

    CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用 SSL（Secure Sockets Layer，安全套接 层和TLS（TransportLayerSecurity，传输层安全）协议把通信内容加密后经网络隧道传输。 

    ...

### 2.4 Connection: keep-alive

这是HTTP/1.1提出的解决办法，解决的问题是TCP/IP多次链接关闭造成的开销。
如果没有持久链接，访问一个页面的时候，要请求图片、数据等资源，就会开闭多次TCP/IP协议，这样的开销是没有必要的，建立keep-alive的机制，保证了只需要建立一次TCP/IP链接，完成所有的请求。

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。
管线化的方式让并行的请求得以实现，速度更快。

### 2.5 再说Cookie

Cookie技术的诞生是为了解决HTTP协议本身是无状态的问题。

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

具体流程：

1. 客户端发送一个请求
    ```
    GET /index.html HTTP/1.1
    Host: demo.jp
    ```

2. 服务端响应的时候加入Set-Cookie，并记住这个cookie是给谁的
    ```
    HTTP/1.1 200 OK
    Date: 略
    Server: Apache
    <Set-Cookie: sid= 16516165165165;path="/"; expires=Wed, 10-Oct-12 07:12:20 GMT>
    ```

3. 客服端再次发送请求的时候就会带上这个Cookie
    ```
    GET /index.html HTTP/1.1
    Host: demo.jp
    Cookie: sid= 16516165165165
    ```

4. 服务端接收到后去对比Cookie,就会获取到之前的状态信息。

    Cookie的更多内容还是在后边...在后边...在后边...

## 3. HTTP报文详细解析

### 3.1 报文的结构

报文的结构大致分为首部、空行、主体三个部分。

<img src="./bw.png">

报文首部中主要包含了请求行、状态行、请求首部字段、响应首部字段、实体首部字段、通用首部字段等。

<img src="./bwjg.png">

### 3.2 提升传输的效率

通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

实体 = 实体首部 + 实体主体。

一下提升传输效率的编码均作用于实体。

1. 内容编码

    内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

    常用的内容编码有：
    gzip、compress等

2. 分块传输编码
    
    在传输大容量数据时，通过把数据分割成多块(chunk)，能够让浏览器逐步显示页面。
    


### 3.3 MIME

MIME(多用途因特网邮件拓展)的使用场景：我们可以发送不同数据类型的内容附件，但是邮件依然可以处理。它通过Multipart(多部分对象集合)来容纳不同类型的数据。

HTTP也有这样的机制。常见于文件、图片上传的场景。

我们常常使用的 Content-type 就是指定多部分对象集合对象的。包括：

1. multipart/form-data 
    
    上传表单文件的时候使用。

2. multipart/byteranges

    状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。

    第1个类型很常用。就不赘述了，第2个常用于获取一部分访问范围数据或者多个范围的数据。简单举例就是，请求一个10000字节的图片文件，先获取图片的上半部分，再获取下半部。要和另一个首部字段 Content-Range 配合使用。

    ```
    Content-Range: bytes=5001-10000        // 5001-10000字节的内容
    Content-Range: bytes=5001-             // 5001字节以后的
    Content-Range: bytes=-3000, 5000-7000  // 从开始到3000字节以及5000-7000范围
    ```


### 3.4 内容协商

场景：访问Google中文版和英文版，浏览器设置中文或者英文。
然后访问同一个地址：www.google.com，就可以实现。这样的机制就叫做内容协商。

概念：内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准

包含在请求报文中的某些首部字段（如下）就是判断的基准。比如 Accept等。后边在说..

内容协商的技术类型：

1. 服务器驱动协商

    由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。这样对用户不一定是最准确的。

2. 客户端驱动协商

    由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以通过JavaScript脚本自动的选择。

3. 透明协商

    上述方式的结合体，服务端和客户端各自进行内容协商。


## 4. HTTP状态码

状态码的结构是：

```
200 OK
```

由一个三位数字的状态码 + 状态码原因短语组成。

大致分为5类：
1. 1XX --> 接收的请求正在处理 
2. 2XX --> 请求正常处理完毕 
3. 3XX --> 需要进行附加操作以完成请求  
4. 4XX --> 服务器无法处理请求 
5. 5XX --> 服务器处理请求出错


### 4.1 常用状态码

状态码至少有60种以上，但是我们常用的就那么几种。

#### 4.1.1 2XX 成功

1. 200 OK

    这是最理想的结果。请求被正常、成功的处理了，你可以获得你想要的响应。

2. 204 No Content

    表示请求发送成功，服务器也处理了，但是没有返回一个实体。适用于只想发送数据到服务端，而不需要返回什么资源的场景。

3. 206 Partial Content

    针对某一范围的请求成功了，并可以GET到你想要的那部分Range的数据。也就是说响应报文中包含由 Content-Range 指定范围的实体内容。

#### 4.1.2 3XX 重定向

1. 301 Moved Permanently

    永久性的重定向。该状态码表示请求资源分配了新的URL，以后应该使用资源现在对应的URL了。

2. 302 Found

    临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 

3. 303 See Other

    该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303其实和302功能是一样的，但是303要求必须是GET请求。

4. 304 Not Modified

    该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX 类别中，但是和重定向没有关系。

    附带条件的请求是指采用GET方法的请求报文中包含If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。 

5. 307 Temporary Redirect

    临时重定向，与302也是差别不多的。主要是限制了POST请求变为GET请求。

#### 4.1.3 4XX 客户端错误

出现4XX的状态码说明了错误是发生在客户端。

1. 400 Bad Request

    该状态码表示请求报文中存在语法错误。你能做的就是check你的请求内容，然后重新发送。

2. 401 Unauthorized

    该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。服务端会返回两次401响应，第一次对应会弹出一个对话框让你填写用户名、密码啥的认证信息，第二次返回401就是表示 bad credentials，你GG了，认证失败。

3. 403 Forbidden

    该状态码表明对请求资源的访问被服务器丑拒了。这还是挺常见的，跨域不就是！

4. 404 Not Found

    该状态码表明服务器上无法找到请求的资源。仔细看看你的地址之类的...

#### 4.1.4 5XX 服务端错误

5XX 的响应结果表明服务器本身发生错误

1. 500 Internal Server Error

    该状态码表明服务器端在执行请求时发生了错误，后台的服务可能出现了Bug。

2. 503 Service Unavailable

    该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
    这样对客户端有点不友好，最好加入一个RetryAfter首部字段信息，告诉客户端什么时候能调用。

状态码是我们调试程序很依靠的凭据，但是也不能全信，坑爹的是有时候web内部发生了错误，也有可能返回200 OK。你能怎么办呢。哎~


## 5. Web服务器

